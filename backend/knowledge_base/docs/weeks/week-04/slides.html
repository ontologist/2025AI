<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Week 4: Search - Breadth-first and Depth-first</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #2563eb 0%, #7c3aed 100%);
            color: #333;
            overflow: hidden;
        }

        .slide-container {
            width: 100vw;
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }

        .slide {
            display: none;
            background: white;
            width: 90%;
            max-width: 1200px;
            height: 85vh;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            padding: 60px 80px;
            position: relative;
            overflow-y: auto;
        }

        .slide.active {
            display: block;
            animation: slideIn 0.5s ease-out;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .slide h1 {
            font-size: 3em;
            color: #2563eb;
            margin-bottom: 20px;
            text-align: center;
        }

        .slide h2 {
            font-size: 2.2em;
            color: #7c3aed;
            margin-bottom: 30px;
            border-bottom: 3px solid #2563eb;
            padding-bottom: 10px;
        }

        .slide h3 {
            font-size: 1.8em;
            color: #2563eb;
            margin-top: 30px;
            margin-bottom: 15px;
        }

        .slide h4 {
            font-size: 1.4em;
            color: #555;
            margin-top: 20px;
            margin-bottom: 10px;
        }

        .slide p {
            font-size: 1.2em;
            line-height: 1.8;
            margin-bottom: 15px;
            color: #444;
        }

        .slide ul, .slide ol {
            font-size: 1.2em;
            line-height: 1.8;
            margin-left: 40px;
            margin-bottom: 20px;
        }

        .slide li {
            margin-bottom: 10px;
        }

        .bilingual {
            display: flex;
            flex-direction: column;
            gap: 20px;
            margin: 20px 0;
        }

        .english, .japanese {
            padding: 20px;
            border-radius: 10px;
        }

        .english {
            background: #dbeafe;
            border-left: 4px solid #2563eb;
        }

        .japanese {
            background: #f3e8ff;
            border-left: 4px solid #7c3aed;
        }

        .highlight-box {
            background: #fef3cd;
            border-left: 5px solid #f59e0b;
            padding: 20px;
            margin: 20px 0;
            border-radius: 5px;
        }

        .code-box {
            background: #f4f4f4;
            border: 1px solid #ddd;
            border-radius: 5px;
            padding: 15px;
            font-family: 'Courier New', monospace;
            margin: 15px 0;
            overflow-x: auto;
            white-space: pre-wrap;
            font-size: 1em;
        }

        .navigation {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 20px;
            z-index: 1000;
        }

        .nav-btn {
            background: white;
            color: #2563eb;
            border: 2px solid #2563eb;
            padding: 12px 30px;
            font-size: 1.1em;
            border-radius: 30px;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        .nav-btn:hover {
            background: #2563eb;
            color: white;
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
        }

        .nav-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .slide-number {
            position: fixed;
            top: 70px;
            right: 30px;
            background: rgba(255, 255, 255, 0.9);
            padding: 10px 20px;
            border-radius: 20px;
            font-size: 1.1em;
            color: #2563eb;
            font-weight: bold;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            z-index: 1000;
        }

        .title-slide {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            height: 100%;
        }

        .title-slide h1 {
            font-size: 4em;
            margin-bottom: 20px;
        }

        .title-slide .subtitle {
            font-size: 2em;
            color: #7c3aed;
            margin-bottom: 40px;
        }

        .title-slide .info {
            font-size: 1.3em;
            color: #666;
            margin: 10px 0;
        }

        .two-column {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin: 20px 0;
        }

        .tree-diagram {
            background: #f9fafb;
            border: 2px solid #e5e7eb;
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
            text-align: center;
            font-family: 'Courier New', monospace;
            font-size: 1em;
        }

        /* Responsive Design */
        @media screen and (max-width: 1024px) {
            .slide {
                padding: 40px 50px;
            }

            .slide h1 {
                font-size: 2.5em;
            }

            .slide h2 {
                font-size: 2em;
            }
        }

        @media screen and (max-width: 768px) {
            .slide-container {
                padding: 0;
            }

            .slide {
                width: 100vw;
                height: auto;
                min-height: 100vh;
                padding: 20px;
                border-radius: 0;
            }

            .slide h1 {
                font-size: 2em;
            }

            .slide h2 {
                font-size: 1.6em;
            }

            .bilingual {
                gap: 15px;
            }

            .two-column {
                grid-template-columns: 1fr;
            }

            .title-slide h1 {
                font-size: 2.5em;
            }

            .title-slide .subtitle {
                font-size: 1.4em;
            }

            .navigation {
                bottom: 15px;
                gap: 10px;
            }

            .nav-btn {
                padding: 10px 20px;
                font-size: 0.95em;
            }
        }

    </style>
    <link rel="stylesheet" href="../../styles.css">
</head>
<body>
    <div class="slide-number" id="slideNumber">Slide 1 / 13</div>

    <div class="slide-container">
        <!-- Slide 1: Title -->
        <div class="slide active title-slide">
            <h1>Week 4</h1>
            <p class="subtitle">Search: Breadth-first and Depth-first<br>探索：幅優先探索と深さ優先探索</p>
            <p class="info"><strong>Course:</strong> Artificial Intelligence</p>
            <p class="info"><strong>Topic:</strong> Basic Search Strategies and Tree Traversal</p>
            <p class="info"><strong>Duration:</strong> 15-20 minutes / 15-20分</p>
        </div>

        <!-- Slide 2: Introduction to Search -->
        <div class="slide">
            <h2>Why Search Matters in AI</h2>
            <h2>AIにおいて探索が重要な理由</h2>
            <div class="highlight-box">
                <h3>Search is Fundamental / 探索は基本</h3>
                <p>Many AI problems involve finding a path from a start state to a goal state</p>
                <p>多くのAI問題は、開始状態から目標状態への経路を見つけることを含みます</p>
            </div>
            <div class="bilingual">
                <div class="english">
                    <h4>Real-World Search Problems:</h4>
                    <ul>
                        <li>Route planning (GPS navigation)</li>
                        <li>Game playing (chess, puzzles)</li>
                        <li>Problem solving (Rubik's cube)</li>
                        <li>Web crawling and indexing</li>
                        <li>Robot path planning</li>
                    </ul>
                </div>
                <div class="japanese">
                    <h4>実世界の探索問題：</h4>
                    <ul>
                        <li>経路計画（GPSナビゲーション）</li>
                        <li>ゲームプレイ（チェス、パズル）</li>
                        <li>問題解決（ルービックキューブ）</li>
                        <li>ウェブクロールとインデックス作成</li>
                        <li>ロボット経路計画</li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- Slide 3: Search Problem Components -->
        <div class="slide">
            <h2>Components of a Search Problem</h2>
            <h2>探索問題の構成要素</h2>
            <div class="bilingual">
                <div class="english">
                    <h4>Five Key Elements:</h4>
                    <ol>
                        <li><strong>Initial State:</strong> Where we start</li>
                        <li><strong>Actions:</strong> Possible moves from each state</li>
                        <li><strong>Transition Model:</strong> Result of taking an action</li>
                        <li><strong>Goal Test:</strong> Check if we reached the goal</li>
                        <li><strong>Path Cost:</strong> Cost of taking a particular path</li>
                    </ol>
                </div>
                <div class="japanese">
                    <h4>5つの主要要素：</h4>
                    <ol>
                        <li><strong>初期状態：</strong>開始地点</li>
                        <li><strong>行動：</strong>各状態から可能な移動</li>
                        <li><strong>遷移モデル：</strong>行動を取った結果</li>
                        <li><strong>目標テスト：</strong>目標に到達したかチェック</li>
                        <li><strong>経路コスト：</strong>特定の経路を取るコスト</li>
                    </ol>
                </div>
            </div>
            <div class="highlight-box">
                <h4>Example: Maze Navigation / 例：迷路ナビゲーション</h4>
                <ul>
                    <li><strong>Initial:</strong> Entrance / 入口</li>
                    <li><strong>Actions:</strong> Move up, down, left, right / 上下左右に移動</li>
                    <li><strong>Goal:</strong> Exit / 出口</li>
                    <li><strong>Cost:</strong> Number of steps / ステップ数</li>
                </ul>
            </div>
        </div>

        <!-- Slide 4: State Space -->
        <div class="slide">
            <h2>State Space and Search Trees</h2>
            <h2>状態空間と探索木</h2>
            <div class="bilingual">
                <div class="english">
                    <h4>State Space:</h4>
                    <p>The set of all possible states reachable from the initial state</p>
                    <h4>Search Tree:</h4>
                    <p>A tree representation where:</p>
                    <ul>
                        <li><strong>Root:</strong> Initial state</li>
                        <li><strong>Nodes:</strong> States</li>
                        <li><strong>Edges:</strong> Actions</li>
                        <li><strong>Leaves:</strong> Goal states or dead ends</li>
                    </ul>
                </div>
                <div class="japanese">
                    <h4>状態空間：</h4>
                    <p>初期状態から到達可能なすべての可能な状態のセット</p>
                    <h4>探索木：</h4>
                    <p>木の表現で：</p>
                    <ul>
                        <li><strong>根：</strong>初期状態</li>
                        <li><strong>ノード：</strong>状態</li>
                        <li><strong>エッジ：</strong>行動</li>
                        <li><strong>葉：</strong>目標状態または行き止まり</li>
                    </ul>
                </div>
            </div>
            <div class="tree-diagram">
                      A
                    /   \
                   B     C
                  / \   / \
                 D   E F   G
            </div>
        </div>

        <!-- Slide 5: Breadth-First Search Introduction -->
        <div class="slide">
            <h2>Breadth-First Search (BFS)</h2>
            <h2>幅優先探索（BFS）</h2>
            <div class="highlight-box">
                <h3>Strategy / 戦略:</h3>
                <p><strong>Explore all nodes at depth d before exploring nodes at depth d+1</strong></p>
                <p><strong>深さd+1のノードを探索する前に、深さdのすべてのノードを探索する</strong></p>
            </div>
            <div class="bilingual">
                <div class="english">
                    <h4>Key Characteristics:</h4>
                    <ul>
                        <li><strong>Level by level:</strong> Explores tree horizontally</li>
                        <li><strong>Uses a queue:</strong> First In, First Out (FIFO)</li>
                        <li><strong>Systematic:</strong> Won't miss any solution</li>
                        <li><strong>Complete:</strong> Finds solution if it exists</li>
                        <li><strong>Optimal:</strong> Finds shortest path (if all costs equal)</li>
                    </ul>
                </div>
                <div class="japanese">
                    <h4>主な特徴：</h4>
                    <ul>
                        <li><strong>レベルごと：</strong>木を水平に探索</li>
                        <li><strong>キューを使用：</strong>先入れ先出し（FIFO）</li>
                        <li><strong>体系的：</strong>解を見逃さない</li>
                        <li><strong>完全：</strong>存在すれば解を見つける</li>
                        <li><strong>最適：</strong>最短経路を見つける（すべてのコストが同じ場合）</li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- Slide 6: BFS Example -->
        <div class="slide">
            <h2>BFS Example: Step by Step</h2>
            <h2>BFS例：ステップバイステップ</h2>
            <div class="tree-diagram">
Start at A, Goal: G

Step 1: Visit A → Queue: [B, C]
Step 2: Visit B → Queue: [C, D, E]
Step 3: Visit C → Queue: [D, E, F, G]
Step 4: Visit D → Queue: [E, F, G]
Step 5: Visit E → Queue: [F, G]
Step 6: Visit F → Queue: [G]
Step 7: Visit G → GOAL FOUND!

Order: A → B → C → D → E → F → G
            </div>
            <div class="bilingual">
                <div class="english">
                    <h4>BFS Process:</h4>
                    <ol>
                        <li>Start with root in queue</li>
                        <li>Remove front node, check if goal</li>
                        <li>Add all children to back of queue</li>
                        <li>Repeat until goal found or queue empty</li>
                    </ol>
                </div>
                <div class="japanese">
                    <h4>BFSプロセス：</h4>
                    <ol>
                        <li>キューに根から始める</li>
                        <li>前のノードを削除し、目標かチェック</li>
                        <li>すべての子をキューの後ろに追加</li>
                        <li>目標が見つかるかキューが空になるまで繰り返す</li>
                    </ol>
                </div>
            </div>
        </div>

        <!-- Slide 7: BFS Pros and Cons -->
        <div class="slide">
            <h2>BFS: Advantages and Disadvantages</h2>
            <h2>BFS：利点と欠点</h2>
            <div class="two-column">
                <div>
                    <h3>Advantages / 利点</h3>
                    <ul>
                        <li><strong>Complete:</strong> Will find a solution if one exists</li>
                        <li><strong>完全：</strong>存在すれば解を見つける</li>
                        <li><strong>Optimal:</strong> Finds shortest path</li>
                        <li><strong>最適：</strong>最短経路を見つける</li>
                        <li><strong>Systematic:</strong> Explores methodically</li>
                        <li><strong>体系的：</strong>方法論的に探索</li>
                    </ul>
                </div>
                <div>
                    <h3>Disadvantages / 欠点</h3>
                    <ul>
                        <li><strong>Memory intensive:</strong> Stores all nodes at current level</li>
                        <li><strong>メモリ集約的：</strong>現在のレベルのすべてのノードを保存</li>
                        <li><strong>Slow for deep goals:</strong> Explores many irrelevant nodes</li>
                        <li><strong>深い目標には遅い：</strong>多くの無関係なノードを探索</li>
                        <li><strong>Exponential growth:</strong> Space complexity O(b^d)</li>
                        <li><strong>指数的成長：</strong>空間複雑度O(b^d)</li>
                    </ul>
                </div>
            </div>
            <div class="highlight-box">
                <p><strong>b</strong> = branching factor (average children per node)</p>
                <p><strong>d</strong> = depth of shallowest solution</p>
                <p><strong>b</strong> = 分岐係数（ノードあたりの平均子数）</p>
                <p><strong>d</strong> = 最も浅い解の深さ</p>
            </div>
        </div>

        <!-- Slide 8: Depth-First Search Introduction -->
        <div class="slide">
            <h2>Depth-First Search (DFS)</h2>
            <h2>深さ優先探索（DFS）</h2>
            <div class="highlight-box">
                <h3>Strategy / 戦略:</h3>
                <p><strong>Explore as deep as possible before backtracking</strong></p>
                <p><strong>バックトラックする前にできるだけ深く探索する</strong></p>
            </div>
            <div class="bilingual">
                <div class="english">
                    <h4>Key Characteristics:</h4>
                    <ul>
                        <li><strong>Depth first:</strong> Explores tree vertically</li>
                        <li><strong>Uses a stack:</strong> Last In, First Out (LIFO)</li>
                        <li><strong>Goes deep:</strong> Follows one path to the end</li>
                        <li><strong>Backtracks:</strong> Returns when dead end reached</li>
                        <li><strong>Memory efficient:</strong> Only stores current path</li>
                    </ul>
                </div>
                <div class="japanese">
                    <h4>主な特徴：</h4>
                    <ul>
                        <li><strong>深さ優先：</strong>木を垂直に探索</li>
                        <li><strong>スタックを使用：</strong>後入れ先出し（LIFO）</li>
                        <li><strong>深く行く：</strong>1つの経路を最後まで追う</li>
                        <li><strong>バックトラック：</strong>行き止まりに達したら戻る</li>
                        <li><strong>メモリ効率的：</strong>現在の経路のみを保存</li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- Slide 9: DFS Example -->
        <div class="slide">
            <h2>DFS Example: Step by Step</h2>
            <h2>DFS例：ステップバイステップ</h2>
            <div class="tree-diagram">
Start at A, Goal: G

Step 1: Visit A → Stack: [B, C]
Step 2: Visit C → Stack: [B, F, G]
Step 3: Visit G → GOAL FOUND!

Order: A → C → G

(Much faster than BFS for this example!)
            </div>
            <div class="bilingual">
                <div class="english">
                    <h4>DFS Process:</h4>
                    <ol>
                        <li>Start with root on stack</li>
                        <li>Pop top node, check if goal</li>
                        <li>Push all children onto stack</li>
                        <li>Repeat until goal found or stack empty</li>
                    </ol>
                    <p><strong>Note:</strong> Order depends on which child is pushed first</p>
                </div>
                <div class="japanese">
                    <h4>DFSプロセス：</h4>
                    <ol>
                        <li>スタックに根から始める</li>
                        <li>トップノードをポップし、目標かチェック</li>
                        <li>すべての子をスタックにプッシュ</li>
                        <li>目標が見つかるかスタックが空になるまで繰り返す</li>
                    </ol>
                    <p><strong>注：</strong>順序は最初にプッシュされる子に依存</p>
                </div>
            </div>
        </div>

        <!-- Slide 10: DFS Pros and Cons -->
        <div class="slide">
            <h2>DFS: Advantages and Disadvantages</h2>
            <h2>DFS：利点と欠点</h2>
            <div class="two-column">
                <div>
                    <h3>Advantages / 利点</h3>
                    <ul>
                        <li><strong>Memory efficient:</strong> Only stores current path</li>
                        <li><strong>メモリ効率的：</strong>現在の経路のみを保存</li>
                        <li><strong>Space:</strong> O(bm) where m = max depth</li>
                        <li><strong>空間：</strong>O(bm) ここでm = 最大深さ</li>
                        <li><strong>Fast:</strong> Can find deep goals quickly</li>
                        <li><strong>高速：</strong>深い目標を素早く見つけられる</li>
                    </ul>
                </div>
                <div>
                    <h3>Disadvantages / 欠点</h3>
                    <ul>
                        <li><strong>Not optimal:</strong> May not find shortest path</li>
                        <li><strong>最適ではない：</strong>最短経路を見つけられない</li>
                        <li><strong>Not complete:</strong> Can get stuck in infinite loops</li>
                        <li><strong>完全ではない：</strong>無限ループにはまる可能性</li>
                        <li><strong>Order dependent:</strong> Result varies with child order</li>
                        <li><strong>順序依存：</strong>結果が子の順序で変わる</li>
                    </ul>
                </div>
            </div>
            <div class="highlight-box">
                <h4>Solution: Depth-Limited DFS</h4>
                <h4>解決策：深さ制限DFS</h4>
                <p>Set a maximum depth limit to prevent infinite loops</p>
                <p>無限ループを防ぐために最大深さ制限を設定</p>
            </div>
        </div>

        <!-- Slide 11: BFS vs DFS Comparison -->
        <div class="slide">
            <h2>BFS vs DFS: Comparison</h2>
            <h2>BFS対DFS：比較</h2>
            <div class="code-box">
Characteristic          BFS             DFS
──────────────────────────────────────────────
Data Structure          Queue           Stack
Completeness            Yes             No (unless limited)
Optimality             Yes*            No
Space Complexity        O(b^d)          O(bm)
Time Complexity         O(b^d)          O(b^m)
Memory Usage            High            Low
Best For               Shallow goals    Deep goals

* Optimal when all step costs are equal
            </div>
            <div class="bilingual">
                <div class="english">
                    <h4>When to Use Each:</h4>
                    <ul>
                        <li><strong>BFS:</strong> Finding shortest path, goal is shallow, need optimal solution</li>
                        <li><strong>DFS:</strong> Goal is deep, memory is limited, any solution acceptable</li>
                    </ul>
                </div>
                <div class="japanese">
                    <h4>それぞれを使用する場合：</h4>
                    <ul>
                        <li><strong>BFS：</strong>最短経路を見つける、目標が浅い、最適解が必要</li>
                        <li><strong>DFS：</strong>目標が深い、メモリが制限されている、任意の解が許容される</li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- Slide 12: Real-World Applications -->
        <div class="slide">
            <h2>Real-World Applications</h2>
            <h2>実世界への応用</h2>
            <div class="two-column">
                <div>
                    <h3>BFS Applications</h3>
                    <h3>BFS応用</h3>
                    <ul>
                        <li><strong>Social networks:</strong> Finding shortest connection between people</li>
                        <li><strong>ソーシャルネットワーク：</strong>人々間の最短接続を見つける</li>
                        <li><strong>GPS navigation:</strong> Shortest route</li>
                        <li><strong>GPSナビゲーション：</strong>最短ルート</li>
                        <li><strong>Web crawlers:</strong> Discover nearby pages first</li>
                        <li><strong>ウェブクローラー：</strong>近くのページを最初に発見</li>
                    </ul>
                </div>
                <div>
                    <h3>DFS Applications</h3>
                    <h3>DFS応用</h3>
                    <ul>
                        <li><strong>Maze solving:</strong> Find any exit</li>
                        <li><strong>迷路解決：</strong>任意の出口を見つける</li>
                        <li><strong>Topological sorting:</strong> Dependency resolution</li>
                        <li><strong>トポロジカルソート：</strong>依存関係の解決</li>
                        <li><strong>Cycle detection:</strong> Finding loops in graphs</li>
                        <li><strong>サイクル検出：</strong>グラフ内のループを見つける</li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- Slide 13: Summary and Next Week -->
        <div class="slide">
            <h2>Summary and Next Steps</h2>
            <h2>まとめと次のステップ</h2>
            <div class="bilingual">
                <div class="english">
                    <h3>Key Takeaways:</h3>
                    <ul>
                        <li><strong>Search is fundamental</strong> to many AI problems</li>
                        <li><strong>BFS:</strong> Explores level-by-level, finds shortest path, uses more memory</li>
                        <li><strong>DFS:</strong> Explores depth-first, memory efficient, may not find optimal solution</li>
                        <li><strong>Trade-offs:</strong> Choose based on problem characteristics</li>
                    </ul>
                    <h3>Next Week: Informed Search</h3>
                    <p>Learn about <strong>Best-First Search</strong> and the <strong>A* Algorithm</strong></p>
                    <p>How to use knowledge (heuristics) to search more efficiently!</p>
                </div>
                <div class="japanese">
                    <h3>重要なポイント：</h3>
                    <ul>
                        <li><strong>探索は基本</strong>多くのAI問題に</li>
                        <li><strong>BFS：</strong>レベルごとに探索、最短経路を見つける、より多くのメモリを使用</li>
                        <li><strong>DFS：</strong>深さ優先で探索、メモリ効率的、最適解を見つけられない可能性</li>
                        <li><strong>トレードオフ：</strong>問題の特性に基づいて選択</li>
                    </ul>
                    <h3>来週：情報探索</h3>
                    <p><strong>最良優先探索</strong>と<strong>A*アルゴリズム</strong>について学ぶ</p>
                    <p>知識（ヒューリスティック）を使用してより効率的に探索する方法！</p>
                </div>
            </div>
        </div>

    </div>

    <div class="navigation">
        <button class="nav-btn" id="prevBtn" onclick="changeSlide(-1)">◀ Previous</button>
        <button class="nav-btn" id="nextBtn" onclick="changeSlide(1)">Next ▶</button>
    </div>

    <script>
        let currentSlide = 0;
        const slides = document.querySelectorAll('.slide');
        const totalSlides = slides.length;

        function showSlide(n) {
            slides[currentSlide].classList.remove('active');
            currentSlide = (n + totalSlides) % totalSlides;
            slides[currentSlide].classList.add('active');

            document.getElementById('slideNumber').textContent = `Slide ${currentSlide + 1} / ${totalSlides}`;

            document.getElementById('prevBtn').disabled = currentSlide === 0;
            document.getElementById('nextBtn').disabled = currentSlide === totalSlides - 1;
        }

        function changeSlide(direction) {
            showSlide(currentSlide + direction);
        }

        // Keyboard navigation
        document.addEventListener('keydown', function(event) {
            if (event.key === 'ArrowLeft') {
                changeSlide(-1);
            } else if (event.key === 'ArrowRight' || event.key === ' ') {
                event.preventDefault();
                changeSlide(1);
            } else if (event.key === 'Home') {
                showSlide(0);
            } else if (event.key === 'End') {
                showSlide(totalSlides - 1);
            }
        });

        // Initialize
        showSlide(0);
    </script>
</body>
</html>
