<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Week 6: Game Theory and Game Trees</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background: linear-gradient(135deg, #2563eb 0%, #7c3aed 100%); color: #333; overflow: hidden; }
        .slide-container { width: 100vw; height: 100vh; display: flex; align-items: center; justify-content: center; position: relative; }
        .slide { display: none; background: white; width: 90%; max-width: 1200px; height: 85vh; border-radius: 20px; box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3); padding: 60px 80px; position: relative; overflow-y: auto; }
        .slide.active { display: block; animation: slideIn 0.5s ease-out; }
        @keyframes slideIn { from { opacity: 0; transform: translateY(30px); } to { opacity: 1; transform: translateY(0); } }
        .slide h1 { font-size: 3em; color: #2563eb; margin-bottom: 20px; text-align: center; }
        .slide h2 { font-size: 2.2em; color: #7c3aed; margin-bottom: 30px; border-bottom: 3px solid #2563eb; padding-bottom: 10px; }
        .slide h3 { font-size: 1.8em; color: #2563eb; margin-top: 30px; margin-bottom: 15px; }
        .slide h4 { font-size: 1.4em; color: #555; margin-top: 20px; margin-bottom: 10px; }
        .slide p { font-size: 1.2em; line-height: 1.8; margin-bottom: 15px; color: #444; }
        .slide ul, .slide ol { font-size: 1.2em; line-height: 1.8; margin-left: 40px; margin-bottom: 20px; }
        .slide li { margin-bottom: 10px; }
        .bilingual { display: flex; flex-direction: column; gap: 20px; margin: 20px 0; }
        .english, .japanese { padding: 20px; border-radius: 10px; }
        .english { background: #dbeafe; border-left: 4px solid #2563eb; }
        .japanese { background: #f3e8ff; border-left: 4px solid #7c3aed; }
        .highlight-box { background: #fef3cd; border-left: 5px solid #f59e0b; padding: 20px; margin: 20px 0; border-radius: 5px; }
        .success-box { background: #d1fae5; border-left: 5px solid #10b981; padding: 20px; margin: 20px 0; border-radius: 5px; }
        .code-box { background: #f4f4f4; border: 1px solid #ddd; border-radius: 5px; padding: 15px; font-family: 'Courier New', monospace; margin: 15px 0; overflow-x: auto; white-space: pre-wrap; font-size: 1em; }
        .navigation { position: fixed; bottom: 30px; left: 50%; transform: translateX(-50%); display: flex; gap: 20px; z-index: 1000; }
        .nav-btn { background: white; color: #2563eb; border: 2px solid #2563eb; padding: 12px 30px; font-size: 1.1em; border-radius: 30px; cursor: pointer; transition: all 0.3s; box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2); }
        .nav-btn:hover { background: #2563eb; color: white; transform: translateY(-2px); box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3); }
        .nav-btn:disabled { opacity: 0.5; cursor: not-allowed; }
        .slide-number { position: fixed; top: 70px; right: 30px; background: rgba(255, 255, 255, 0.9); padding: 10px 20px; border-radius: 20px; font-size: 1.1em; color: #2563eb; font-weight: bold; box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1); z-index: 1000; }
        .title-slide { display: flex; flex-direction: column; justify-content: center; align-items: center; text-align: center; height: 100%; }
        .title-slide h1 { font-size: 4em; margin-bottom: 20px; }
        .title-slide .subtitle { font-size: 2em; color: #7c3aed; margin-bottom: 40px; }
        .title-slide .info { font-size: 1.3em; color: #666; margin: 10px 0; }
        .two-column { display: grid; grid-template-columns: 1fr 1fr; gap: 30px; margin: 20px 0; }
        @media screen and (max-width: 768px) {
            .slide { width: 100vw; height: auto; min-height: 100vh; padding: 20px; border-radius: 0; }
            .slide h1 { font-size: 2em; }
            .slide h2 { font-size: 1.6em; }
            .bilingual { gap: 15px; }
            .two-column { grid-template-columns: 1fr; }
            .title-slide h1 { font-size: 2.5em; }
            .title-slide .subtitle { font-size: 1.4em; }
        }
    </style>
</head>
<body>
    <div class="slide-number" id="slideNumber">Slide 1 / 13</div>

    <div class="slide-container">
        <div class="slide active title-slide">
            <h1>Week 6</h1>
            <p class="subtitle">Game Theory and Game Trees<br>ゲーム理論とゲーム木探索</p>
            <p class="info"><strong>Course:</strong> Artificial Intelligence</p>
            <p class="info"><strong>Topic:</strong> Minimax and Alpha-Beta Pruning</p>
            <p class="info"><strong>Duration:</strong> 15-20 minutes / 15-20分</p>
        </div>

        <div class="slide">
            <h2>Introduction to Game Playing</h2>
            <h2>ゲームプレイの紹介</h2>
            <div class="highlight-box">
                <h3>Why Games Matter in AI / ゲームがAIで重要な理由</h3>
                <p>Games provide a perfect testbed for AI techniques</p>
                <p>ゲームはAI技術の完璧なテストベッドを提供します</p>
            </div>
            <div class="bilingual">
                <div class="english">
                    <h4>Classic AI Game Milestones:</h4>
                    <ul>
                        <li><strong>1997:</strong> Deep Blue defeats Kasparov at chess</li>
                        <li><strong>2011:</strong> Watson wins Jeopardy!</li>
                        <li><strong>2016:</strong> AlphaGo defeats Lee Sedol at Go</li>
                        <li><strong>2019:</strong> AlphaStar reaches Grandmaster level in StarCraft II</li>
                    </ul>
                </div>
                <div class="japanese">
                    <h4>古典的なAIゲームのマイルストーン：</h4>
                    <ul>
                        <li><strong>1997年：</strong>ディープブルーがカスパロフをチェスで倒す</li>
                        <li><strong>2011年：</strong>ワトソンがジェパディで優勝</li>
                        <li><strong>2016年：</strong>AlphaGoがイ・セドルを囲碁で倒す</li>
                        <li><strong>2019年：</strong>AlphaStarがStarCraft IIでグランドマスターレベルに到達</li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="slide">
            <h2>Adversarial Search</h2>
            <h2>敵対的探索</h2>
            <div class="bilingual">
                <div class="english">
                    <h3>Difference from Regular Search:</h3>
                    <ul>
                        <li><strong>Regular search:</strong> Find path to goal (environment is static)</li>
                        <li><strong>Adversarial search:</strong> Opponent tries to stop you (dynamic, competitive)</li>
                    </ul>
                    <h4>Game Characteristics:</h4>
                    <ul>
                        <li><strong>Two players:</strong> MAX (us) and MIN (opponent)</li>
                        <li><strong>Turn-based:</strong> Players alternate moves</li>
                        <li><strong>Perfect information:</strong> Both see entire game state</li>
                        <li><strong>Zero-sum:</strong> What one wins, the other loses</li>
                    </ul>
                </div>
                <div class="japanese">
                    <h3>通常の探索との違い：</h3>
                    <ul>
                        <li><strong>通常の探索：</strong>目標への経路を見つける（環境は静的）</li>
                        <li><strong>敵対的探索：</strong>対戦相手があなたを止めようとする（動的、競争的）</li>
                    </ul>
                    <h4>ゲームの特性：</h4>
                    <ul>
                        <li><strong>2人のプレーヤー：</strong>MAX（私たち）とMIN（対戦相手）</li>
                        <li><strong>ターンベース：</strong>プレーヤーは交互に移動</li>
                        <li><strong>完全情報：</strong>両方ともゲーム状態全体を見る</li>
                        <li><strong>ゼロサム：</strong>一方が勝つと、他方が負ける</li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="slide">
            <h2>Game Trees</h2>
            <h2>ゲーム木</h2>
            <div class="code-box">
Tic-Tac-Toe Example:

           X's turn (MAX)
          /     |     \
      X|_|_  _|X|_  _|_|X
         |        |        |
    O's turn   O's turn   O's turn (MIN)
    /  |  \    /  |  \    /  |  \
   ...  ...  ...  ...  ...  ...

Leaf nodes = terminal states (win/loss/draw)
            </div>
            <div class="bilingual">
                <div class="english">
                    <h4>Game Tree Components:</h4>
                    <ul>
                        <li><strong>Nodes:</strong> Game states (board configurations)</li>
                        <li><strong>Edges:</strong> Possible moves</li>
                        <li><strong>MAX levels:</strong> Our turn to move</li>
                        <li><strong>MIN levels:</strong> Opponent's turn</li>
                        <li><strong>Terminal nodes:</strong> End of game (win/loss/draw)</li>
                    </ul>
                </div>
                <div class="japanese">
                    <h4>ゲーム木のコンポーネント：</h4>
                    <ul>
                        <li><strong>ノード：</strong>ゲーム状態（ボード構成）</li>
                        <li><strong>エッジ：</strong>可能な移動</li>
                        <li><strong>MAXレベル：</strong>私たちのターン</li>
                        <li><strong>MINレベル：</strong>対戦相手のターン</li>
                        <li><strong>終端ノード：</strong>ゲーム終了（勝ち/負け/引き分け）</li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="slide">
            <h2>Minimax Algorithm</h2>
            <h2>ミニマックスアルゴリズム</h2>
            <div class="success-box">
                <h3>Core Idea / 核心的アイデア:</h3>
                <p><strong>MAX wants to maximize score, MIN wants to minimize it</strong></p>
                <p><strong>MAXはスコアを最大化したい、MINはそれを最小化したい</strong></p>
            </div>
            <div class="bilingual">
                <div class="english">
                    <h4>The Strategy:</h4>
                    <ul>
                        <li><strong>MAX player:</strong> Choose move that maximizes minimum guaranteed payoff</li>
                        <li><strong>MIN player:</strong> Choose move that minimizes maximum possible loss</li>
                        <li><strong>Assumption:</strong> Opponent plays optimally</li>
                    </ul>
                    <h4>Algorithm Steps:</h4>
                    <ol>
                        <li>Generate full game tree to terminal states</li>
                        <li>Apply utility function to terminal states</li>
                        <li>Propagate values upward:
                            <ul>
                                <li>MAX nodes: take maximum of children</li>
                                <li>MIN nodes: take minimum of children</li>
                            </ul>
                        </li>
                        <li>Choose best move at root</li>
                    </ol>
                </div>
                <div class="japanese">
                    <h4>戦略：</h4>
                    <ul>
                        <li><strong>MAXプレーヤー：</strong>最小保証ペイオフを最大化する移動を選択</li>
                        <li><strong>MINプレーヤー：</strong>最大可能損失を最小化する移動を選択</li>
                        <li><strong>仮定：</strong>対戦相手は最適にプレイする</li>
                    </ul>
                    <h4>アルゴリズムのステップ：</h4>
                    <ol>
                        <li>終端状態まで完全なゲーム木を生成</li>
                        <li>終端状態に効用関数を適用</li>
                        <li>値を上向きに伝播：
                            <ul>
                                <li>MAXノード：子の最大値を取る</li>
                                <li>MINノード：子の最小値を取る</li>
                            </ul>
                        </li>
                        <li>ルートで最良の移動を選択</li>
                    </ol>
                </div>
            </div>
        </div>

        <div class="slide">
            <h2>Minimax Example</h2>
            <h2>ミニマックスの例</h2>
            <div class="code-box">
                  MAX
                /     \
              MIN     MIN
             /  \    /  \
            3    12  8   2
            
Step 1: MIN chooses minimum
        Left MIN: min(3,12) = 3
        Right MIN: min(8,2) = 2

Step 2: MAX chooses maximum
        MAX: max(3,2) = 3
        
Decision: MAX chooses LEFT branch
            </div>
            <div class="bilingual">
                <div class="english">
                    <p><strong>Key insight:</strong> MAX assumes MIN plays optimally against them</p>
                    <p>Even though 12 looks attractive, MIN will never allow MAX to reach it</p>
                </div>
                <div class="japanese">
                    <p><strong>重要な洞察：</strong>MAXはMINが最適にプレイすることを仮定</p>
                    <p>12は魅力的に見えるが、MINはMAXがそれに到達することを決して許さない</p>
                </div>
            </div>
        </div>

        <div class="slide">
            <h2>Minimax Properties</h2>
            <h2>ミニマックスの性質</h2>
            <div class="two-column">
                <div>
                    <h3>Advantages / 利点</h3>
                    <ul>
                        <li><strong>Optimal:</strong> Finds best move if opponent plays optimally</li>
                        <li><strong>最適：</strong>対戦相手が最適にプレイする場合に最良の移動を見つける</li>
                        <li><strong>Complete:</strong> Always finds solution</li>
                        <li><strong>完全：</strong>常に解を見つける</li>
                        <li><strong>Guarantees:</strong> Best possible outcome</li>
                        <li><strong>保証：</strong>最良の可能な結果</li>
                    </ul>
                </div>
                <div>
                    <h3>Limitations / 制限</h3>
                    <ul>
                        <li><strong>Exponential complexity:</strong> O(b^m)</li>
                        <li><strong>指数的複雑度：</strong>O(b^m)</li>
                        <li><strong>Impractical:</strong> Can't explore full tree for chess (10^120 nodes!)</li>
                        <li><strong>非実用的：</strong>チェスの完全な木を探索できない（10^120ノード！）</li>
                        <li><strong>Needs optimization:</strong> Too slow for complex games</li>
                        <li><strong>最適化が必要：</strong>複雑なゲームには遅すぎる</li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="slide">
            <h2>Alpha-Beta Pruning</h2>
            <h2>アルファベータ枝刈り</h2>
            <div class="success-box">
                <h3>The Optimization / 最適化:</h3>
                <p><strong>Skip parts of tree that won't affect final decision</strong></p>
                <p><strong>最終決定に影響しない木の部分をスキップする</strong></p>
            </div>
            <div class="bilingual">
                <div class="english">
                    <h4>Key Insight:</h4>
                    <p>If we know a move is worse than a previously examined one, we can ignore it</p>
                    <h4>Two Values Track Progress:</h4>
                    <ul>
                        <li><strong>Alpha (α):</strong> Best value MAX can guarantee so far</li>
                        <li><strong>Beta (β):</strong> Best value MIN can guarantee so far</li>
                    </ul>
                    <h4>Pruning Rule:</h4>
                    <p>If α ≥ β, stop exploring that branch</p>
                </div>
                <div class="japanese">
                    <h4>重要な洞察：</h4>
                    <p>移動が以前に調べたものより悪いことがわかっている場合、それを無視できます</p>
                    <h4>進行状況を追跡する2つの値：</h4>
                    <ul>
                        <li><strong>アルファ（α）：</strong>MAXがこれまでに保証できる最良の値</li>
                        <li><strong>ベータ（β）：</strong>MINがこれまでに保証できる最良の値</li>
                    </ul>
                    <h4>枝刈りルール：</h4>
                    <p>α ≥ βの場合、そのブランチの探索を停止</p>
                </div>
            </div>
        </div>

        <div class="slide">
            <h2>Alpha-Beta Example</h2>
            <h2>アルファベータの例</h2>
            <div class="code-box">
              MAX (α=-∞, β=+∞)
              /              \
          MIN               MIN
         /  \              /  \
        3    12           8    ?
        
1. Visit left MIN: finds 3
   α=3 at MAX level
   
2. Visit right MIN: finds 8
   But MAX already has 3 as option
   Since 8 > 3, and this is MIN level,
   MIN could give even worse...
   
3. PRUNE! No need to check "?"
   MAX will choose left (3) anyway
            </div>
            <div class="bilingual">
                <div class="english">
                    <p><strong>Result:</strong> Same answer as minimax, but faster!</p>
                    <p>Explored 3 nodes instead of 4 (25% reduction)</p>
                </div>
                <div class="japanese">
                    <p><strong>結果：</strong>ミニマックスと同じ答え、しかしより速い！</p>
                    <p>4ノードではなく3ノードを探索（25%削減）</p>
                </div>
            </div>
        </div>

        <div class="slide">
            <h2>Alpha-Beta Effectiveness</h2>
            <h2>アルファベータの効果</h2>
            <div class="highlight-box">
                <h3>Performance Gain / パフォーマンス向上</h3>
                <p><strong>With perfect move ordering:</strong></p>
                <p><strong>完璧な移動順序で：</strong></p>
                <ul>
                    <li>Minimax: O(b^m) nodes</li>
                    <li>Alpha-Beta: O(b^(m/2)) nodes</li>
                    <li><strong>Doubles search depth!</strong> m → 2m</li>
                    <li><strong>探索深さを2倍に！</strong> m → 2m</li>
                </ul>
            </div>
            <div class="bilingual">
                <div class="english">
                    <h4>Practical Impact:</h4>
                    <p>In chess (b≈35):</p>
                    <ul>
                        <li>Minimax depth 4: 35^4 = 1.5 million nodes</li>
                        <li>Alpha-beta depth 8: 35^4 = same nodes!</li>
                        <li>Can look 4 moves ahead instead of 2</li>
                    </ul>
                </div>
                <div class="japanese">
                    <h4>実用的影響：</h4>
                    <p>チェスで（b≈35）：</p>
                    <ul>
                        <li>ミニマックス深さ4：35^4 = 150万ノード</li>
                        <li>アルファベータ深さ8：35^4 = 同じノード！</li>
                        <li>2手先ではなく4手先を見られる</li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="slide">
            <h2>Evaluation Functions</h2>
            <h2>評価関数</h2>
            <div class="bilingual">
                <div class="english">
                    <h3>The Practical Problem:</h3>
                    <p>Can't search to end of game in complex games</p>
                    <h4>Solution: Evaluation Function</h4>
                    <p>Estimate the value of a non-terminal state</p>
                    <h4>Chess Example:</h4>
                    <ul>
                        <li>Material: Pawn=1, Knight=3, Bishop=3, Rook=5, Queen=9</li>
                        <li>Position: Control of center, king safety</li>
                        <li>Mobility: Number of legal moves</li>
                    </ul>
                    <p><strong>Eval(state) = material + position + mobility...</strong></p>
                </div>
                <div class="japanese">
                    <h3>実用的問題：</h3>
                    <p>複雑なゲームではゲームの終わりまで探索できない</p>
                    <h4>解決策：評価関数</h4>
                    <p>非終端状態の値を推定する</p>
                    <h4>チェスの例：</h4>
                    <ul>
                        <li>駒の価値：ポーン=1、ナイト=3、ビショップ=3、ルーク=5、クイーン=9</li>
                        <li>位置：中央の制御、王の安全性</li>
                        <li>機動性：合法的な移動の数</li>
                    </ul>
                    <p><strong>Eval(状態) = 駒の価値 + 位置 + 機動性...</strong></p>
                </div>
            </div>
        </div>

        <div class="slide">
            <h2>Real-World Game AI</h2>
            <h2>実世界のゲームAI</h2>
            <div class="bilingual">
                <div class="english">
                    <h3>Modern Approaches:</h3>
                    <ul>
                        <li><strong>Deep Blue (1997):</strong> Minimax + alpha-beta + custom hardware</li>
                        <li><strong>AlphaGo (2016):</strong> Monte Carlo Tree Search + deep neural networks</li>
                        <li><strong>Modern games:</strong> Combine search with machine learning</li>
                    </ul>
                    <h4>Beyond Perfect Information:</h4>
                    <ul>
                        <li><strong>Poker:</strong> Incomplete information, probability</li>
                        <li><strong>Real-time strategy:</strong> Large state space, time pressure</li>
                        <li><strong>Multi-player:</strong> Coalitions, negotiations</li>
                    </ul>
                </div>
                <div class="japanese">
                    <h3>現代のアプローチ：</h3>
                    <ul>
                        <li><strong>ディープブルー（1997年）：</strong>ミニマックス + アルファベータ + カスタムハードウェア</li>
                        <li><strong>AlphaGo（2016年）：</strong>モンテカルロ木探索 + 深層ニューラルネットワーク</li>
                        <li><strong>現代のゲーム：</strong>探索と機械学習を組み合わせる</li>
                    </ul>
                    <h4>完全情報を超えて：</h4>
                    <ul>
                        <li><strong>ポーカー：</strong>不完全情報、確率</li>
                        <li><strong>リアルタイム戦略：</strong>大きな状態空間、時間的圧力</li>
                        <li><strong>マルチプレーヤー：</strong>連合、交渉</li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="slide">
            <h2>Summary and Next Week</h2>
            <h2>まとめと来週</h2>
            <div class="bilingual">
                <div class="english">
                    <h3>Key Takeaways:</h3>
                    <ul>
                        <li><strong>Adversarial search:</strong> Games with opponents</li>
                        <li><strong>Minimax:</strong> Optimal strategy assuming optimal opponent</li>
                        <li><strong>Alpha-beta pruning:</strong> Dramatically reduces nodes explored</li>
                        <li><strong>Evaluation functions:</strong> Estimate value of non-terminal states</li>
                        <li><strong>Trade-offs:</strong> Depth vs. breadth, speed vs. optimality</li>
                    </ul>
                    <h3>Next Week: Probability and Bayes</h3>
                    <p>Learn about <strong>probabilistic reasoning</strong>, <strong>Bayes' theorem</strong>, and <strong>handling uncertainty</strong></p>
                    <p>How AI deals with incomplete information!</p>
                </div>
                <div class="japanese">
                    <h3>重要なポイント：</h3>
                    <ul>
                        <li><strong>敵対的探索：</strong>対戦相手とのゲーム</li>
                        <li><strong>ミニマックス：</strong>最適な対戦相手を仮定した最適戦略</li>
                        <li><strong>アルファベータ枝刈り：</strong>探索されるノードを劇的に削減</li>
                        <li><strong>評価関数：</strong>非終端状態の値を推定</li>
                        <li><strong>トレードオフ：</strong>深さ対幅、速度対最適性</li>
                    </ul>
                    <h3>来週：確率とベイズ</h3>
                    <p><strong>確率的推論</strong>、<strong>ベイズの定理</strong>、<strong>不確実性の処理</strong>について学ぶ</p>
                    <p>AIが不完全な情報にどのように対処するか！</p>
                </div>
            </div>
        </div>

    </div>

    <div class="navigation">
        <button class="nav-btn" id="prevBtn" onclick="changeSlide(-1)">◀ Previous</button>
        <button class="nav-btn" id="nextBtn" onclick="changeSlide(1)">Next ▶</button>
    </div>

    <script>
        let currentSlide = 0;
        const slides = document.querySelectorAll('.slide');
        const totalSlides = slides.length;
        function showSlide(n) {
            slides[currentSlide].classList.remove('active');
            currentSlide = (n + totalSlides) % totalSlides;
            slides[currentSlide].classList.add('active');
            document.getElementById('slideNumber').textContent = `Slide ${currentSlide + 1} / ${totalSlides}`;
            document.getElementById('prevBtn').disabled = currentSlide === 0;
            document.getElementById('nextBtn').disabled = currentSlide === totalSlides - 1;
        }
        function changeSlide(direction) { showSlide(currentSlide + direction); }
        document.addEventListener('keydown', function(event) {
            if (event.key === 'ArrowLeft') { changeSlide(-1); }
            else if (event.key === 'ArrowRight' || event.key === ' ') { event.preventDefault(); changeSlide(1); }
            else if (event.key === 'Home') { showSlide(0); }
            else if (event.key === 'End') { showSlide(totalSlides - 1); }
        });
        showSlide(0);
    </script>
</body>
</html>
